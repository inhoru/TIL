# 🔖 목차
1. [배열의 선언](#1-배열의-선언)<br/>
2. [배열의 구조](#2-배열의-구조)<br/>
3. [배열 방 불러오기](#3-배열-방-불러오기)<br/>
4. [여러개의 배열 선언](#4-여러개의-배열-선언)<br/>
5. [배열의 복사](#5-배열의-복사)<br/>


<br/>

> 이제 진짜 배열에대해 자세히 배워보자.
> 
> 
> 먼저 배열을 선언하는 방법과 
> 
> 선얼을 했을 때 구조에대해서 알아보고.
> 
> 1차원 배열선언 방법 그리고 저장 출력까지
> 
> 자세히 공부해보자
> 
> 2차배열은 다음에 더욱 자세히 다루겠다



<br/>

# 1. 배열의 선언

- 먼저 배열을 선언하는 방법에대해서 알아볼려고한다.

  - 배열을 선언한 **변수는 참조변수이기 때문에 값자체가 아닌 주소를 저장한다**

<br/>

- 배열을 선언해보기에 앞서 변수를 불러와보자
  - 변수를 끌어들이는 이유는 변수에서 확장된 것이기 때문이다

<br/>

- 이해를 돕기위해 먼저 int타입의 변수를 하나 선언해보겠다.

        int i = 0;
<br/>

- 이 코드가 무슨뜻을 가지고 있는지 잘알고있을것이다.
- 그래서 이제 이코드를 배열로 바꿔보려고한다.
        int[]i=new int[n];
        
<br/>

- 앞에서 변수를 선언한 코드에서[]{대괄호}를 더 붙여서 새로운 코드를 작성했다.
- 이게 바로 배열을 선언하는 방법이다.

  - 기본형 과 달리 = 뒤에 **new**가 등장했다.
  - 그렇다면?  변수i는 기본형 타입이아닌 **참조형 타입**이라는것 알수있다

<br/>

## int[]

- 기본형 타입 뒤에 [] 를 붙인것뿐이다.

  - 이말은 즉 int가 아니라 **int배열** 이라는 뜻이 된다.
  - 다시말해 배열 타입의 변수라는의미이다.
  - 그리고 int뿐만아니라 **double,char,long,String**등등 여러가지 조형타입이 가능하다.

- 하나 주의할점이있다.

  - int[]와 같이 이렇게 선언을했다면 **배열에 저장할수 있는 값은 같은 타입안 int타입만가능하다.**
  - String[] 이라고 배열을 선언한다면 이배열에는 String타입의 값만 저장이 가능하다는거다.

<br/>

## new int[n];

- 갑자기 뒤에 뭐가 붙었다 하지만 우리가 자주보고 자주썻던것이랑 비슷하다.
- **new String();** 과 같은것이라고 생각하면된다.

  - **new 연산자는 메모리의 heap영역에 공간을 만들어두는 역할이다.**
  - 그공간에서 우리가 만든 int[]의 형태의 방으로 만드는 것이다.

- int[] 안에 있는n은 내가 생성할때 만들 배열의 방 개수를 의마한다.

  - 예를 들어 10을넣는다면 <code>new int[10]</code> 의 형태가 될것이고 배열은 선언한거다.
  - 총 10개의 값을 저장할 수있는 공간을 만들겠다는 뜻이다.
  - 이를 **인덱스**라고 표현할수있다.

- 배열을 선언하게 되면 10개의 빈방이 만들어지고 빈방안에는 해당배열 타입의 기본형이 자동적으로 저장된다.
- 여기서 타입이 <code>int</code> 타입이기때문에 <code>int</code>의 기본값인 0이 방마다 자동으로저장된다

<br/>

# 2. 배열의 구조

- 배열은 기본적으로 방처럼 되어있고 인덱스라는 방번호를 부여받는다.

  - 인덱스는 0부터 시작해 사용자가 지정한 방 개수의 -1까지 부여가 된다.
  - **int[4] 로했다면 0부터 4까지 0,1,2,3 <- 이렇게 4개의방이 부여된다**


- 방에서 선언만 한다면 기본값이 자동으로 들어가서 초기화가 된다.

  - 위에서 말했듯이 int[]타입은 0이고 다른 타입마다 초기값이 들어간다.
  - 그리고 변수는 **참조형변수** 이기 때문에 heap영역에 들어간다는거 잊지말자.

<br/>

![1차원배열](http://www.sysout.co.kr/file/image/1460)

<br/>

> 위에 그림의 배열 형태가 가장 기본적인 배열의 형태인데
> 
> 우리는 이걸**1차원배열** 이라고 한다.
> 
> 1차원이 있다면 자동적으로 2차원 3차원도 있다고 생각할텐데
> 
> 맞다.. 2차원 배열은 다음 에 더자세히 배우겠다.
> 
> 일단 1차원배열이 이런느낌이다 라는것만 알고있자.

<br/>

# 3. 배열 방 불러오기

- 배열의 선언을 배웠다 그러면 이제 배열의 저장된 방들은 어떻게 불러올까?

  - 배열을 가르키는 변수명 뒤에 **[]와 해당하는 인덱스 번호를 적어주면 끝이다**
  - i[1] 가 인덱스 2번의 변수가 되는것이다.
  - 그리고 헷갈릴수도있는데 현재 i의타입은 int[]배열타입이다.
  - 그런데 **방을 가리키는 변수i[2]는 타입이 int[]이 아니라int가되는것이다.**
  - 예를 들자면 i=2;는 불가능하지만 i[2]=2; 는 가능하다는뜻이다

<br/>

# 4. 여러개의 배열 선언

- 위에서 썬던 int[] i = new int[]; 는 가장 기본적인방법이다.
- 이거 말고 배열을 선언하는 방법이 여러개존재한다.
- 편한것을 사용하자. 

## int[] i = new int[n];

- 위에서부터 썻던 선언 방법이다.

- 배열을 선언하고 선언한 배열의 방에 **자동적으로 기본값이 저장되는 과정**까지 실행된다.
- 직접값을 저장하지 않기 때문에 나중에 원하는 값을 넣는 과정이필요하다

<br/>

## int[] i = new int[]{1,2,3,4,5,};

- 이방법은 배열의 선언과 동시에 초기화를 하는방법이다.
- 원래는 []안에 배열의 방 개수를 적어줘야했지만 {} 를 하고 값을 적어주면 자신이 입력한 값의 개수만큼 방이 생성된다.

<br/>


# 5. 배열 초기화

- 배열의 초기화 방법도 여러가지가 있다 대표적으로 3가지만 알아보자

## 인덱스를 이용한 초기화

- 우리가 변수에서 썻던 방법이랑 비슷하다.

        arr[0] = 1;
        arr[1] = 2;
        
- 이런식으로 변수의 초기화 와 비슷하다.



<br/>     

## for문을 이용한 초기화

- 배열은  for문과 굉장히 인접해 있다고 말한적이있다.
- 그래서 for문으로도 초기화가 가능하다

        ex)for(int i =0; i <arr.length; i++) {
                arr[i] = i;
         }

- index가 순차적으로 증가함에 따라 초기화할 리터럴 값이 규칙적이라면
- 반복문을 통해 배열초기화가 가능하다.
- **arr.length** 를쓴이유는 어차피 변수의 방개수만큼 반복할거이기때문에 일일히 length 를쓴다면 일일히 바꿔주지않아도된다.


<br/>


# 5. 배열의 복사


- 배열 에는 **얕은 복사, 깊은복사** 두가지의 복사방법이있다

    - 1. 얕은 복사 : 원본값을 공유하는 방식이다.
    - 2. 깊은 복사 : 별도의 저장 공간을 생성해서 데이터를 따로 관리하는 방식이다.

<br/>


## 1.  얕은 복사

![얕은복사](https://user-images.githubusercontent.com/126074577/224480214-754ea264-16bb-4658-b552-4fcbf162c2a0.png)

- **이제 배열의 얕은 복사를 알아볼거다.**
- **얕은 복사란 객체의 주소 값만 가져와서 참조형 변수에 저장하고**
- **하나의 객체를 두변수가 참조하는 것을만한다.**

  - 예를들어보겠다.

```java
int [] num = {1,2,3,4,5,};

int [] copynum = num;

System.out.println(num);
System.out.println("num" + Arrays.toString(num));// for문안쓰고 전체를 출력하는 기능
System.out.println("copynum" + Arrays.toString(copynum));
System.out.println("num[0] : " + num[0]);
System.out.println("copynum[0] : " + copynum[0]);

// 주소값을 공유하기때문에 저장소가 한개!
num[0] = 100;// 위에서 주소값을 공유했기때문에 하나에만 넣어도 같아진다.
System.out.println("num : " + num[0]);
System.out.println("copynum : " + copynum[0]);
```
<br/>

- 얕은 복사는 주소값을 공유하기 한다.

  - 때문에 num 이라는 배열에 값을넣으면 그주소값에 들어가기때문에
  - copyum 을 출력을해도 num이랑 주소를공유하기때문에 같은 값이출력이된다.
  - 이게 얕은 복사이다.
<br/>


## 2. 깊은복사

![깊은복사](https://user-images.githubusercontent.com/126074577/224480220-8dc528c8-856f-4322-9c2c-961bd698ba28.png)

- **얕은 복사는 주소값을 복사해서 같은 주소값을 썻다면**
- **깊은 복사는 값자체를 복사해서 새로운 저장소에 저장한다.**

  - 예를들어보겠다.

```java
int[] num = { 1, 2, 3, 4, 5 };
int[] deepcopy = new int[num.length];
for (int i = 0; i < num.length; i++) {
deepcopy[i] = num[i];
}
System.out.println("num : " + Arrays.toString(num));
System.out.println("deepcopy : " + Arrays.toString(deepcopy));
num[1] = 200;// num에있는 주소를 수정한거지 deepcopy에있는 주소를 수정한게아니다.
System.out.println("num : " + Arrays.toString(num));
System.out.println("deepcopy : " + Arrays.toString(deepcopy));
```
<br/>

- **기존에 배열의 데이터를 복사했다.**

  - 쉽게말하자면 num[]길이를 복사했다는거다
  - 복사만 했으니 초기값이 들어있을거다.
  - 그렇기에for문으로 모든 방에 값을넣어줫다

- **그리고num[1]의 값을 200으로 바꾼후 출력해보자**

  - 출력결과는 num[1]의 값만 200으로 바뀌고
  - deepcopy의 값은 1 이다.

- **왜그럴까?**

  - 간단하다  deepcopy는 num의 배열의 방만 복사하고 새로운주소에생겻기때문이다
  - 서로 방의길이만 같고  주소는 다르니 변경을하더라도 적용이될리가없다.
  - 이게 깊은복사이다.
<br/>

## 자바에서 제공하는 깊은복사 기능

- **자바에서도 깊은복사를 하는 기능이있다**
- **1. <code>Arrays.copyOf();</code>이다.**

  - 예를보자

```java
int[] num = { 1, 2, 3, 4, 5 };
		
		
int[] copy2 = Arrays.copyOf(num, 2);// num의 배열의길이중 2번째까지만 복사하겟다
System.out.println("copy2 : " + Arrays.toString(copy2));

//출력결과
//copy2 : [1, 2]
```

- **이런식으로 자기가 복사하고싶은 범위를 선택할수 있는기능이다.**
- <br/>

- **배열전체를 깊은복사를하고싶으면 clone() 이용해도된다.**

```java
copy = num.clone(); //배열전체 깊은복사
System.out.println("copy" + Arrays.toString(copy));
```

        
<br/>

- **2. <code>System.arraycopy()</code> **
- 이건 세세하게 복사를할때 사용한다.

  - 예를먼저들어보자

```java
String[] names = { "김아무", "홍길동", "김유신" };
		String[] extend = new String[names.length + 5];
		System.arraycopy(names, 1, extend, 3, 2);
		for (int i = 0; i < extend.length; i++) {
			System.out.print(extend[i] + " ");
		}
		System.out.println();
```
<br/>

- **여기서 System.arraycopy(names, 1, extend, 3, 2); 괄호안이 가리키는것은 뭘까?**

   - 첫번째 : 원본배열
	 - 두번째 : 원본배열 시작인덱스
	 - 세번째 : 복사된 배열
	 - 네번째 : 복사될 배열의 시작인덱스
	 - 다섯번째 : 복사할 데이터 수(길이)

- **이렇게 순서에맞춰 괄호안을 수정하면 세세하게 깊은복사가 가능하다.**




 




 





